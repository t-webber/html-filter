use std::fs;
use std::path::PathBuf;

fn get_files(path: PathBuf) -> Vec<PathBuf> {
    let mut res = vec![];
    let files = path.read_dir().unwrap();
    for file in files {
        let file = file.unwrap();
        if file.file_type().unwrap().is_dir() {
            res.extend(get_files(file.path()))
        } else {
            res.push(file.path());
        }
    }
    res
}

fn main() {
    let source_code = get_files(PathBuf::from("src"))
        .iter()
        .flat_map(|file| {
            fs::read_to_string(dbg!(file))
                .unwrap()
                .lines()
                .map(|line| line.trim())
                .filter(|line| line.starts_with("///"))
                .map(|line| line.get(4..).unwrap_or_default().to_owned())
                .collect::<Vec<String>>()
        })
        .collect::<Vec<String>>();
    dbg!(&source_code);
    let mut idx = 0;
    let mut tests = String::new();
    let mut code = false;
    let mut current = String::new();
    tests.push_str(
"//! This file is not meant for manual editing.\n//! This file is automatically generated by `build.rs` script.\n//! Any changes made will be discarded.\n");
    for line in source_code {
        if matches!(line.as_str(), "```" | "```rust") {
            if code {
                idx += 1;
                dbg!(&current);
                tests.push_str(&format!(
                    "
#[test]
fn auto_doctest_{idx}() {{
{current}}}
"
                ));
                current.clear();
            }
            code = !code;
        } else if code && !line.trim().is_empty() {
            dbg!(&line);
            current.push_str("    ");
            current.push_str(&line);
            current.push('\n');
        }
    }
    fs::write("tests/doctests.rs", tests).unwrap();
}
